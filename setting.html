<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENV 파일 편집기</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .tabs { display: flex; margin-bottom: 15px; border-bottom: 1px solid #ccc; }
        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #eee;
            margin-right: 5px;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }
        .tab-button.active {
            background-color: #fff;
            border-color: #ccc;
            border-bottom: 1px solid #fff;
            position: relative;
            bottom: -1px;
        }
        .tab-content { display: none; padding: 20px; border: 1px solid #ccc; border-top: none; background-color: #fff; }
        .tab-content.active { display: block; }
        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        .form-group label .key-name { font-size: 0.9em; color: #666; font-weight: normal; margin-left: 5px;}
        .form-group input[type="text"],
        .form-group input[type="password"],
        .form-group textarea {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .form-group input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
        .form-group .description { font-size: 0.85em; color: #777; margin-top: 3px; }
        .save-button, .action-button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 10px;
        }
        .save-button:hover, .action-button:hover { background-color: #0056b3; }
        h2 { color: #333; border-bottom: 1px solid #eee; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center;}
        .initial-load-area { margin-bottom: 20px; border: 1px dashed #ccc; padding: 15px; background-color: #f9f9f9; }
        .initial-load-area label { display: block; margin-bottom: 8px; font-weight: bold; }
        .initial-load-area input[type="file"] { margin-bottom: 10px; }
        .file-info { font-size: 0.9em; color: #555; margin-bottom: 10px; padding: 10px; background-color: #e9ecef; border-radius: 4px;}
        .file-info .warning { color: #dc3545; font-weight: bold; margin-top: 5px; }
        .reset-button { background-color: #6c757d; font-size: 0.8em; padding: 8px 12px;}
        .reset-button:hover { background-color: #545b62; }
        .form-placeholder {
            padding: 20px;
            text-align: center;
            color: #777;
            border: 2px dashed #ddd;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <h1>ENV 파일 편집기</h1>
    <p style="background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px; border-radius: 5px;">
        <strong>참고:</strong> 이 도구는 브라우저에서 실행되며, 보안상의 이유로 파일을 직접 수정할 수 없습니다.<br>
        먼저 해당 환경 파일을 선택하여 설정을 불러온 후 수정하고, '파일로 저장' 버튼을 통해 다운로드하여 기존 파일을 대체해주세요.
        <a href="https://sideways-attic-cbb.notion.site/AutoBlog-v1-Manual-f900839ee91b476593252d0abf54c502" target="_blank">매뉴얼 링크</a>
    </p>

    <div class="tabs">
        <button class="tab-button active" onclick="openTab(event, 'commonEnv')">공통 설정 (.env)</button>
        <button class="tab-button" onclick="openTab(event, 'bloggerEnv')">블로거 설정 (blogger.env)</button>
        <button class="tab-button" onclick="openTab(event, 'tistoryEnv')">티스토리 설정 (tistory.env)</button>
    </div>

    <div id="commonEnv" class="tab-content active">
        <h2>공통 설정 (.env) <button class="action-button reset-button" onclick="clearFormAndPromptForFile('commonEnv', '.env')">다른 파일 선택 / 초기화</button></h2>
        <div class="initial-load-area" id="commonEnvLoadArea">
            <label for="commonEnvFile">.env 파일을 선택하여 설정을 불러오세요.</label>
            <input type="file" id="commonEnvFile" accept=".env,text/plain" onchange="handleFileSelect('commonEnvFile', 'commonEnvFileInfo', 'commonEnv', '.env')">
            <div id="commonEnvFileInfo" class="file-info">파일이 선택되지 않았습니다.</div>
        </div>
        <div id="commonEnvForm"><p class="form-placeholder">.env 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p></div>
        <button class="save-button" onclick="saveEnvFile('commonEnv', '.env')" disabled>저장 비활성화 (파일 로드 필요)</button>
    </div>

    <div id="bloggerEnv" class="tab-content">
        <h2>블로거 설정 (blogger.env) <button class="action-button reset-button" onclick="clearFormAndPromptForFile('bloggerEnv', 'blogger.env')">다른 파일 선택 / 초기화</button></h2>
        <div class="initial-load-area" id="bloggerEnvLoadArea">
            <label for="bloggerEnvFile">blogger.env 파일을 선택하여 설정을 불러오세요.</label>
            <input type="file" id="bloggerEnvFile" accept=".env,text/plain" onchange="handleFileSelect('bloggerEnvFile', 'bloggerEnvFileInfo', 'bloggerEnv', 'blogger.env')">
            <div id="bloggerEnvFileInfo" class="file-info">파일이 선택되지 않았습니다.</div>
        </div>
        <div id="bloggerEnvForm"><p class="form-placeholder">blogger.env 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p></div>
        <button class="save-button" onclick="saveEnvFile('bloggerEnv', 'blogger.env')" disabled>저장 비활성화 (파일 로드 필요)</button>
    </div>

    <div id="tistoryEnv" class="tab-content">
        <h2>티스토리 설정 (tistory.env) <button class="action-button reset-button" onclick="clearFormAndPromptForFile('tistoryEnv', 'tistory.env')">다른 파일 선택 / 초기화</button></h2>
        <div class="initial-load-area" id="tistoryEnvLoadArea">
            <label for="tistoryEnvFile">tistory.env 파일을 선택하여 설정을 불러오세요.</label>
            <input type="file" id="tistoryEnvFile" accept=".env,text/plain" onchange="handleFileSelect('tistoryEnvFile', 'tistoryEnvFileInfo', 'tistoryEnv', 'tistory.env')">
            <div id="tistoryEnvFileInfo" class="file-info">파일이 선택되지 않았습니다.</div>
        </div>
        <div id="tistoryEnvForm"><p class="form-placeholder">tistory.env 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p></div>
        <button class="save-button" onclick="saveEnvFile('tistoryEnv', 'tistory.env')" disabled>저장 비활성화 (파일 로드 필요)</button>
    </div>

    <script>
        const keyTitles = {
            ".env": { "OPEN_AI_KEY": "OpenAI API 키", "MY_ASSISTANT_ID": "Open AI 어시스턴트 ID", "COUPANG_USERNAME": "쿠팡 아이디", "COUPANG_PASSWORD": "쿠팡 비밀번호", "NAVER_CLIENT_ID": "네이버 클라이언트 ID", "NAVER_CLIENT_SECRET": "네이버 클라이언트 시크릿", "CUSTOMER_ID": "CUSTOMER ID", "NAVER_SEARCH_KEY": "네이버 검색 API 키", "NAVER_SEARCH_SECRET": "네이버 검색 API 시크릿", "CHANNEL_ID": "채널 ID (쉼표 구분)", "USE_GPT_IMAGE_CREATION": "GPT 이미지 생성 사용" ,"USE_SHORT_URL":"단축 URL 사용", "BANNED_WORDS": "금지어"},
            "blogger.env": { "COUPANG_PRODUCT_LIMIT": "쿠팡 상품 배너 표시 개수", "USE_GPT_IMAGE_CREATION": "GPT 이미지 생성 사용", "USE_COUPANG_IMAGE": "쿠팡 이미지 사용(필수)", "USE_COUPANG_REVIEW": "쿠팡 리뷰 사용(AI 리뷰 사용 필수)", "USE_COUPANG_AI_REVIEW": "쿠팡 AI 리뷰 사용(필수)", "USE_COUPANG_AI_GUIDE": "쿠팡 AI 가이드 사용", "USE_MY_COUPANG_LINKS": "내 쿠팡 링크 사용", "USE_ROCKET_SHIPPING": "로켓 배송 상품만", "USE_EXACT_SEARCH_MATCHING": "정확히 일치하는 상품명 검색", "USE_CUSTOM_TITLE_BANNER": "커스텀 타이틀 배너 사용","USE_GPT_POST_TITLE": "GPT 쿠파스 타이틀 제목 생성","USE_GPT_POST_DESCRIPTION": "GPT 쿠파스 소개글 작성" ,"TEMPLATE_NAME": "템플릿 이름", "TITLE_BANNER_TEMPLATE_NAME": "타이틀 배너 템플릿 이름", "GOOGLE_CLIENT_SECRETS_PATH": "구글 클라이언트 시크릿 경로", "BLOGGER_BLOG_IDS": "블로거 블로그 ID (쉼표 구분)", "USE_SEARCH_CONSOLE": "구글 서치 콘솔 사용" },
            "tistory.env": { "KAKAO_USERNAME": "카카오 계정", "KAKAO_PASSWORD": "카카오 비밀번호", "COUPANG_PRODUCT_LIMIT": "쿠팡 상품 표시 개수", "TISTORY_DOMAINS": "티스토리 도메인 (쉼표 구분)", "TISTORY_CATEGORY": "티스토리 카테고리", "USE_GPT_IMAGE_CREATION": "GPT 이미지 생성 사용", "USE_COUPANG_IMAGE": "쿠팡 이미지 사용(필수)", "USE_COUPANG_REVIEW": "쿠팡 리뷰 사용(AI 리뷰 사용 필수)", "USE_COUPANG_AI_REVIEW": "쿠팡 AI 리뷰 사용(필수)", "USE_COUPANG_AI_GUIDE": "쿠팡 AI 가이드 사용", "USE_MY_COUPANG_LINKS": "내 쿠팡 링크 사용", "USE_ROCKET_SHIPPING": "로켓 배송 상품만", "USE_EXACT_SEARCH_MATCHING": "정확히 일치하는 검색", "USE_CUSTOM_TITLE_BANNER": "커스텀 타이틀 배너 사용", "USE_GPT_POST_TITLE": "GPT 쿠파스 타이틀 제목 생성","USE_GPT_POST_DESCRIPTION": "GPT 쿠파스 소개글 작성", "TEMPLATE_NAME": "템플릿 이름", "TITLE_BANNER_TEMPLATE_NAME": "타이틀 배너 템플릿 이름" }
        };

        const specialFieldsHelp = {
            "CHANNEL_ID": "쉼표(,)로 구분하여 여러 채널 ID를 입력하세요. (예: id1,id2,id3)",
            "KAKAO_USERNAME": "여러 계정 사용시 쉼표(,)로 구분하여 여러 계정을 적어주세요. 티스토리 구 계정은 계정 뒤에 (:tistory) 를 적어주세요. (예: user1,user2:tistory,user3)",
            "KAKAO_PASSWORD": "KAKAO_USERNAME에 입력한 계정의 순서와 동일하게 쉼표(,)로 구분하여 비밀번호를 적어주세요.",
            "BLOGGER_BLOG_IDS": "쉼표(,)로 구분하여 여러 블로그 ID를 입력하세요. (예: id1,id2,id3)",
            "TISTORY_DOMAINS": "쉼표(,)로 구분하여 여러 티스토리 서브 도메인(또는 외부 도메인 https:// 없이)을 입력하세요. (예: domain1 , www.custom.com)",
            "TISTORY_CATEGORY": "형식: domain1:카테고리1,카테고리2|www.custom.com:카테고리A,카테고리B\n'domain' 부분은 TISTORY_DOMAINS에 입력한 값과 일치해야 합니다. 카테고리 없음의 경우 (예: real-auroro:\\\\카테고리\\\\없음) 으로 입력해주세요.",
            "USE_COUPANG_AI_REVIEW": "반드시 쿠팡 리뷰를 사용하여야 합니다.",
            "USE_MY_COUPANG_LINKS": "product_links.json 파일에 정의된 쿠팡 상품 링크를 사용합니다.",
            "TEMPLATE_NAME": "templates/ 경로안에 있는 example1-example13.html 파일 중 맘에 드는 템플릿을 사용합니다. 확장자는 제외하고 파일 이름만 적어줍니다. 랜덤으로 사용하시려면 random 을 적어주세요.",
            "TITLE_BANNER_TEMPLATE_NAME": "/templates/title_banner/ 경로 안에 있는 banner_type_1.html - banner_type_5.html 파일 중에서 맘에 드는 템플릿을 사용합니다. 확장자는 제외하고 파일 이름만 적어줍니다. 이 이미지는 티스토리의 대표 이미지로 사용됩니다.",
            "USE_CUSTOM_TITLE_BANNER": "체크를 해제하면 상품 이미지를 대표 이미지로 사용합니다." ,
            "USE_GPT_POST_TITLE": "쿠파스 수동 작성시 제목을 GPT로 생성합니다. 사용하지 않아도 템플릿을 이용하여 생성합니다.",
            "USE_GPT_POST_DESCRIPTION": "쿠파스 수동 작성시 소개글을 GPT로 생성합니다. 사용하지 않아도 템플릿을 이용하여 생성합니다.",
            "USE_SHORT_LINK": "쿠팡 링크를 그대로 노출합니다.",
            "BANNED_WORDS": "검색시 노출 금지어를 설정합니다. , 를 구분자로 여러개 입력 가능합니다."

        };
        
        let currentFileStructure = {};
        const hiddenKeys = ['USE_KEYWORD', 'USE_AUTOMATION'];
        
        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            const currentTab = document.getElementById(tabName);
            currentTab.style.display = "block";
            evt.currentTarget.className += " active";

            const formContainer = document.getElementById(tabName + 'Form');
            const fileKey = getFileKeyForTab(tabName);
            if (!currentFileStructure[fileKey] && formContainer.children.length === 1 && formContainer.children[0].classList.contains('form-placeholder')) {
                // Do nothing
            } else if (!currentFileStructure[fileKey]) {
                 formContainer.innerHTML = `<p class="form-placeholder">${fileKey} 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p>`;
                 const saveButton = currentTab.querySelector('.save-button');
                 if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
                 }
            }
        }
        
        function getFileKeyForTab(tabId) {
            if (tabId === 'commonEnv') return '.env';
            if (tabId === 'bloggerEnv') return 'blogger.env';
            if (tabId === 'tistoryEnv') return 'tistory.env';
            return null;
        }

        function handleFileSelect(fileInputId, fileInfoId, tabId, expectedFileKey) {
            const fileInput = document.getElementById(fileInputId);
            const fileInfoDiv = document.getElementById(fileInfoId);
            const formContainer = document.getElementById(tabId + 'Form');
            const saveButton = document.querySelector(`#${tabId} .save-button`);

            fileInfoDiv.innerHTML = '파일이 선택되지 않았습니다.'; 

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const fileName = file.name;

                let isValidFileName = false;
                if (expectedFileKey === '.env') {
                    isValidFileName = (fileName === expectedFileKey || fileName.endsWith(expectedFileKey)) && 
                                      fileName !== 'blogger.env' && fileName !== 'tistory.env';
                    if (!isValidFileName && (fileName === 'blogger.env' || fileName === 'tistory.env')) {
                         // no-op, isValidFileName is false
                    } else if (!isValidFileName && fileName.includes('.env')) {
                        isValidFileName = true; 
                    } else if (fileName !== expectedFileKey && !fileName.endsWith(expectedFileKey) && !fileName.includes('env')) {
                        isValidFileName = false;
                    } else if (fileName === expectedFileKey || fileName.endsWith(expectedFileKey)) {
                         isValidFileName = true;
                    }
                } else { 
                    isValidFileName = (fileName === expectedFileKey);
                }

                if (!isValidFileName) {
                    alert(`선택한 파일(${fileName})이 현재 탭에서 예상하는 파일(${expectedFileKey})과 다릅니다. 올바른 파일을 선택해주세요.`);
                    fileInfoDiv.innerHTML = `오류: <span class="warning">잘못된 파일(${fileName})입니다. ${expectedFileKey} 파일을 선택해주세요.</span>`;
                    fileInput.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    const fileContent = e.target.result;
                    if (!fileContent.trim()) {
                        alert("선택한 파일의 내용이 비어있습니다. 다른 파일을 선택해주세요.");
                        fileInfoDiv.innerHTML = `오류: 선택한 파일 (${file.name}) 내용이 비어있습니다. <span class="warning">다른 파일을 선택해주세요.</span>`;
                        fileInput.value = ''; 
                        delete currentFileStructure[expectedFileKey];
                        formContainer.innerHTML = `<p class="form-placeholder">${expectedFileKey} 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p>`;
                        if (saveButton) {
                            saveButton.disabled = true;
                            saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
                        }
                        return;
                    }

                    fileInfoDiv.innerHTML = `불러온 파일: ${file.name} (${(file.size / 1024).toFixed(2)} KB).`;
                    formContainer.innerHTML = ''; 
                    
                    const parsedStructure = parseEnvContent(fileContent);
                    currentFileStructure[expectedFileKey] = parsedStructure;
                    generateForm(parsedStructure.envVars, tabId + 'Form', expectedFileKey, parsedStructure.originalOrder);
                    
                    if (saveButton) {
                        saveButton.disabled = false;
                        saveButton.textContent = `${expectedFileKey} 파일로 저장`;
                    }

                    if (expectedFileKey === 'tistory.env') {
                        const tistoryDomains = parsedStructure.envVars['TISTORY_DOMAINS'] || "";
                        const tistoryCategory = parsedStructure.envVars['TISTORY_CATEGORY'] || "";
                        const validationResult = validateTistorySettings(tistoryDomains, tistoryCategory);
                        if (!validationResult.isValid) {
                            const warningEl = document.createElement('div');
                            warningEl.className = 'warning';
                            warningEl.innerHTML = `<strong>경고:</strong> 로드된 tistory.env 설정에 문제가 있습니다.<br>${validationResult.message.replace(/\n/g, '<br>')}`;
                            fileInfoDiv.appendChild(warningEl);
                        }
                    }
                };
                reader.onerror = function(e) {
                    alert("파일을 읽는 중 오류가 발생했습니다.");
                    fileInfoDiv.innerHTML = "파일 읽기 오류. <span class='warning'>다시 시도해주세요.</span>";
                    if (saveButton) {
                        saveButton.disabled = true;
                        saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
                    }
                };
                reader.readAsText(file);
            }
        }
        
        function clearFormAndPromptForFile(tabId, fileKey) {
            const formContainer = document.getElementById(tabId + 'Form');
            formContainer.innerHTML = `<p class="form-placeholder">${fileKey} 파일을 선택하면 여기에 설정 폼이 표시됩니다.</p>`;

            const fileInput = document.getElementById(tabId + 'File');
            if (fileInput) fileInput.value = ''; 

            const fileInfoDiv = document.getElementById(tabId + 'FileInfo');
            if (fileInfoDiv) fileInfoDiv.innerHTML = '파일이 선택되지 않았습니다.';
            
            delete currentFileStructure[fileKey];
            
            const saveButton = document.querySelector(`#${tabId} .save-button`);
            if (saveButton) {
                saveButton.disabled = true;
                saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
            }
        }

        function parseEnvContent(content) {
            const lines = (content || "").split('\n');
            const envVars = {};
            const commentsAndEmptyLines = []; 
            let originalOrder = []; 
            const allLinesFiltered = []; 

            lines.forEach(line => {
                const trimmedLine = line.trim();
                let isHiddenKeyLine = false;

                if (!trimmedLine.startsWith('#') && trimmedLine !== '') {
                    const parts = line.split('=', 2);
                    const key = parts[0].trim();
                    if (hiddenKeys.includes(key)) {
                        isHiddenKeyLine = true;
                    }
                }

                if (!isHiddenKeyLine) {
                    allLinesFiltered.push(line);
                }

                if (trimmedLine.startsWith('#') || trimmedLine === '') {
                    commentsAndEmptyLines.push(line); 
                } else {
                    const parts = line.split('=', 2);
                    const key = parts[0].trim();
                    const value = parts.length > 1 ? parts[1].trim() : ""; 

                    if (key && !hiddenKeys.includes(key)) {
                        envVars[key] = value;
                        originalOrder.push(key);
                    } else if (key && hiddenKeys.includes(key)) {
                        // Do nothing for hidden keys in envVars and originalOrder
                    } else if (line.includes('=')) { 
                         commentsAndEmptyLines.push(line);
                    } else if (trimmedLine !== '') { 
                         commentsAndEmptyLines.push(line);
                    }
                }
            });
            return { envVars, commentsAndEmptyLines, originalOrder, allLines: lines, allLinesFiltered };
        }
        
        function generateForm(envVars, formContainerId, fileKey, originalOrder) {
            const container = document.getElementById(formContainerId);
            container.innerHTML = ''; 

            const currentTitles = keyTitles[fileKey] || {};
            const parentTabId = formContainerId.replace('Form','');
            const saveButton = document.querySelector(`#${parentTabId} .save-button`);

            if (originalOrder.length === 0 && Object.keys(envVars).length === 0) {
                 container.innerHTML = `<p class="form-placeholder">선택한 파일에 유효한 설정 키가 없거나 파일이 비어있습니다. 다른 파일을 선택해주세요.</p>`;
                 if(saveButton) {
                    saveButton.disabled = true;
                    saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
                 }
                 return;
            }

            originalOrder.forEach(key => {
                if (envVars.hasOwnProperty(key) && !hiddenKeys.includes(key)) {
                    const value = envVars[key];
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    
                    let input;
                    const inputId = `${formContainerId}_${key}`;

                    if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = (value.toLowerCase() === 'true');
                        input.id = inputId;
                        
                        const checkLabel = document.createElement('label');
                        checkLabel.htmlFor = inputId;
                        checkLabel.appendChild(input);
                        checkLabel.appendChild(document.createTextNode(` ${currentTitles[key] || key} `));
                        const keySpan = document.createElement('span');
                        keySpan.className = 'key-name';
                        keySpan.textContent = `(${key})`;
                        checkLabel.appendChild(keySpan);
                        formGroup.appendChild(checkLabel);

                    } else if (key === "COUPANG_PASSWORD" || key === "KAKAO_PASSWORD" || key === "NAVER_CLIENT_SECRET" || key === "NAVER_SEARCH_SECRET") {
                        const label = document.createElement('label');
                        label.htmlFor = inputId;
                        label.innerHTML = `${currentTitles[key] || key} <span class="key-name">(${key})</span>`;
                        input = document.createElement('input');
                        input.type = 'password';
                        input.value = value;
                        input.id = inputId;
                        formGroup.appendChild(label);
                        formGroup.appendChild(input);
                    } else {
                        const label = document.createElement('label');
                        label.htmlFor = inputId;
                        label.innerHTML = `${currentTitles[key] || key} <span class="key-name">(${key})</span>`;
                        if (key === "TISTORY_CATEGORY" || key === "GOOGLE_CLIENT_SECRETS_PATH" || (value && value.includes('\n'))) {
                             input = document.createElement('textarea');
                             input.rows = Math.max(2, (value.match(/\n/g) || []).length + 1);
                             if (input.rows > 5) input.rows = 5;
                        } else {
                             input = document.createElement('input');
                             input.type = 'text';
                        }
                        input.value = value;
                        input.id = inputId;
                        formGroup.appendChild(label);
                        formGroup.appendChild(input);
                    }
                    
                    if (specialFieldsHelp[key]) {
                        const description = document.createElement('p');
                        description.className = 'description';
                        description.innerHTML = specialFieldsHelp[key].replace(/\n/g, '<br>');
                        formGroup.appendChild(description);
                    }
                    container.appendChild(formGroup);
                }
            });
             if(saveButton && container.querySelector('.form-group')) {
                saveButton.disabled = false;
                saveButton.textContent = `${fileKey} 파일로 저장`;
             } else if (saveButton) {
                saveButton.disabled = true;
                saveButton.textContent = `저장 비활성화 (파일 로드 필요)`;
             }
        }

        function validateTistorySettings(domainsStr, categoryStr) {
            const domains = domainsStr.split(',').map(d => d.trim()).filter(d => d);
            
            if (domains.length > 0 && !categoryStr.trim()) {
                return { isValid: false, message: "TISTORY_DOMAINS에 도메인이 설정되어 있지만, TISTORY_CATEGORY가 비어있습니다. 각 도메인에 대한 카테고리를 정의해주세요." };
            }
            
            if (domains.length === 0 && categoryStr.trim()) {
                 return { isValid: false, message: "TISTORY_DOMAINS가 비어있는데 TISTORY_CATEGORY 정보가 있습니다. 도메인을 먼저 설정해주세요." };
            }

            if (domains.length === 0 && !categoryStr.trim()) {
                return { isValid: true, message: "" };
            }

            const categoryEntries = categoryStr.split('|').map(c => c.trim()).filter(c => c);
            const categoryDomainMap = new Map();
            const categoryFormatErrors = [];

            for (const entry of categoryEntries) {
                const parts = entry.split(':', 2);
                if (parts.length !== 2 || !parts[0].trim() || !parts[1].trim()) {
                    categoryFormatErrors.push(`- "${entry}" 항목 형식이 올바르지 않습니다. '도메인:카테고리1,카테고리2' 형식이어야 합니다.`);
                    continue;
                }
                const domainKey = parts[0].trim();
                const categories = parts[1].split(',').map(cat => cat.trim());

                if (categories.some(cat => !cat)) {
                    categoryFormatErrors.push(`- "${domainKey}" 도메인의 카테고리 목록에 빈 이름이 있습니다. (예: '카테고리1,,카테고리2') 쉼표(,)를 확인해주세요.`);
                }
                if (categoryDomainMap.has(domainKey)) {
                     categoryFormatErrors.push(`- "${domainKey}" 도메인에 대한 카테고리 정의가 중복되었습니다.`);
                }
                categoryDomainMap.set(domainKey, categories);
            }

            if (categoryFormatErrors.length > 0) {
                return { isValid: false, message: "TISTORY_CATEGORY 형식 오류:\n" + categoryFormatErrors.join("\n") };
            }

            for (const domain of domains) {
                if (!categoryDomainMap.has(domain)) {
                    return { isValid: false, message: `TISTORY_DOMAINS에 정의된 '${domain}' 도메인에 대한 카테고리 정보가 TISTORY_CATEGORY에 없습니다.` };
                }
            }

            for (const catDomain of categoryDomainMap.keys()) {
                if (!domains.includes(catDomain)) {
                    return { isValid: false, message: `TISTORY_CATEGORY에 정의된 '${catDomain}' 도메인이 TISTORY_DOMAINS에 없습니다.` };
                }
            }

            return { isValid: true, message: "" };
        }

        function saveEnvFile(tabId, fileName) {
            const formContainerId = tabId + 'Form';
            const container = document.getElementById(formContainerId);

            if (!container.querySelector('.form-group')) {
                alert("먼저 유효한 파일을 선택하여 설정을 불러와주세요.");
                return;
            }

            const inputs = container.querySelectorAll('input, textarea');
            const currentValues = {};
            inputs.forEach(input => {
                const key = input.id.substring(formContainerId.length + 1);
                if (input.type === 'checkbox') {
                    currentValues[key] = input.checked ? 'True' : 'False';
                } else {
                    currentValues[key] = input.value;
                }
            });

            if (fileName === 'tistory.env') {
                const tistoryDomains = currentValues['TISTORY_DOMAINS'] || "";
                const tistoryCategory = currentValues['TISTORY_CATEGORY'] || "";
                
                const validationResult = validateTistorySettings(tistoryDomains, tistoryCategory);
                if (!validationResult.isValid) {
                    alert(`티스토리 설정 유효성 검사 실패:\n${validationResult.message}`);
                    const domainsInput = document.getElementById(`${formContainerId}_TISTORY_DOMAINS`);
                    const categoryInput = document.getElementById(`${formContainerId}_TISTORY_CATEGORY`);
                    
                    let focused = false;
                    if (validationResult.message.includes("도메인")) {
                        domainsInput?.focus();
                        if(domainsInput) domainsInput.style.borderColor = 'red';
                        setTimeout(() => { if(domainsInput) domainsInput.style.borderColor = ''; }, 3000);
                        focused = true;
                    }
                    if (validationResult.message.includes("카테고리")) {
                        if(!focused) categoryInput?.focus();
                        if(categoryInput) categoryInput.style.borderColor = 'red';
                        setTimeout(() => { if(categoryInput) categoryInput.style.borderColor = ''; }, 3000);
                    }
                    return; 
                }

                // KAKAO_USERNAME과 KAKAO_PASSWORD 개수 검증 추가
                const kakaoUsernamesStr = currentValues['KAKAO_USERNAME'] || "";
                const kakaoPasswordsStr = currentValues['KAKAO_PASSWORD'] || "";

                const usernames = kakaoUsernamesStr.split(',').map(u => u.trim()).filter(u => u); // 공백 아이디 제거
                const passwords = kakaoPasswordsStr.split(',').map(p => p.trim()).filter(p => p); // 공백 비밀번호 제거

                // username이나 password 중 하나라도 입력되었는데, 다른 하나가 비어있거나, 개수가 다르면 오류
                if ((kakaoUsernamesStr.trim() || kakaoPasswordsStr.trim()) && (usernames.length !== passwords.length)) {
                     alert(`카카오 계정 설정 오류:\nKAKAO_USERNAME에 입력된 계정 수(${usernames.length}개)와 KAKAO_PASSWORD에 입력된 비밀번호 수(${passwords.length}개)가 일치하지 않습니다.\n쉼표(,)로 구분되며, 각 계정과 비밀번호는 순서대로 매칭되어야 합니다.\n모두 비워두거나, 계정과 비밀번호 수를 동일하게 맞춰주세요.`);
                    const usernameInput = document.getElementById(`${formContainerId}_KAKAO_USERNAME`);
                    const passwordInput = document.getElementById(`${formContainerId}_KAKAO_PASSWORD`);
                    
                    let focusedEl = null;
                    if (usernameInput) {
                        usernameInput.style.borderColor = 'red';
                        setTimeout(() => { if(usernameInput) usernameInput.style.borderColor = ''; }, 3000);
                        if (usernames.length !== passwords.length) focusedEl = usernameInput; // 수 불일치 시 우선 포커스
                    }
                    if (passwordInput) {
                        passwordInput.style.borderColor = 'red';
                        setTimeout(() => { if(passwordInput) passwordInput.style.borderColor = ''; }, 3000);
                        if (!focusedEl && usernames.length !== passwords.length) focusedEl = passwordInput;
                    }
                    focusedEl?.focus();
                    return;
                }
            }

            let outputLines = [];
            const structure = currentFileStructure[fileName];
            if (!structure || !structure.allLinesFiltered) {
                 alert("오류: 저장할 파일 구조 정보를 찾을 수 없습니다. 파일을 다시 로드해주세요.");
                 return;
            }
            
            structure.allLinesFiltered.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#') || trimmedLine === '') {
                    outputLines.push(line);
                } else {
                    const parts = line.split('=', 2);
                    const key = parts[0].trim();
                    
                    if (key && currentValues.hasOwnProperty(key)) {
                        outputLines.push(`${key}=${currentValues[key]}`);
                    } else if (key && structure.envVars.hasOwnProperty(key) && !hiddenKeys.includes(key)) {
                        // This case should ideally not happen if all keys are in currentValues
                        // but as a fallback, use the original parsed value.
                        outputLines.push(`${key}=${structure.envVars[key]}`);
                    } else if (key && !hiddenKeys.includes(key)){ // For keys not in form (e.g. if form generation failed partially)
                        outputLines.push(line); 
                    } else if (!key && line.includes('=')){ // Lines like '=value' or invalid lines with '='
                        outputLines.push(line);
                    }
                    // Hidden keys are already filtered out from allLinesFiltered
                }
            });
            
            const output = outputLines.join('\n');
        
            let blob;
            if (fileName === '.env') {
                blob = new Blob([output]); 
            } else {
                blob = new Blob([output], { type: 'application/octet-stream' });
            }

            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            alert('다운로드된 파일을 열어서 내용을 '+fileName+' 파일에 붙여넣기 하거나, 파일명을 똑같이 변경하여 덮어씌워 주세요.');
        }
        window.onload = () => {
            document.querySelectorAll('.save-button').forEach(button => {
                button.disabled = true;
                const fileKey = getFileKeyForTab(button.closest('.tab-content').id);
                button.textContent = `저장 비활성화 (${fileKey} 파일 로드 필요)`;
            });
        };

    </script>

</body>
</html>